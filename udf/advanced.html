

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>User-defined functions: advanced topics &mdash; LiberTEM 0.7.0.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Live plotting for LiberTEM UDFs" href="liveplotting.html" />
    <link rel="prev" title="User-defined functions" href="../udf.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> LiberTEM
          

          
            
            <img src="../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">User manual</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">GUI usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../formats.html">Loading data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sample_datasets.html">Sample Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">Python API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../udf.html">User-defined functions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../udf.html#getting-started">Getting started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../udf.html#how-udfs-works">How UDFs works</a></li>
<li class="toctree-l2"><a class="reference internal" href="../udf.html#implementing-a-udf">Implementing a UDF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../udf.html#running-udfs">Running UDFs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../udf.html#more-about-udfs">More about UDFs</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">User-defined functions: advanced topics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tiled-processing">Tiled processing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#post-processing">Post-processing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pre-processing">Pre-processing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#partition-processing">Partition processing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#precedence">Precedence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aux-data">AUX data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-data">Task data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#meta-information">Meta information</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dtype-support">dtype support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cupy-support">CuPy support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#auto-udf">Auto UDF</a></li>
<li class="toctree-l4"><a class="reference internal" href="#live-plotting">Live Plotting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#partial-results">Partial results</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="profiling.html">Profiling UDFs</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citing.html">Citing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../acknowledgments.html">Acknowledgments</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">Python API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tips.html">Tips and tricks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../packages.html">Package overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../concepts.html">Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../performance.html">Performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../why_python.html">Why Python?</a></li>
</ul>
<p class="caption"><span class="caption-text">For developers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dev/setup.html">Setting up a development environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture.html">Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev/how-io-works.html">How does I/O work in LiberTEM?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gsoc.html">GSoC 2020 ideas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../authorship.html">Authorship policy</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">LiberTEM</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../udf.html">User-defined functions</a> &raquo;</li>
        
      <li>User-defined functions: advanced topics</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/udf/advanced.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="user-defined-functions-advanced-topics">
<span id="advanced-udf"></span><h1>User-defined functions: advanced topics<a class="headerlink" href="#user-defined-functions-advanced-topics" title="Permalink to this headline">¶</a></h1>
<p>See <a class="reference internal" href="../udf.html#user-defined-functions"><span class="std std-ref">User-defined functions</span></a> for an introduction to basic topics.</p>
<div class="section" id="tiled-processing">
<span id="tiled"></span><h2>Tiled processing<a class="headerlink" href="#tiled-processing" title="Permalink to this headline">¶</a></h2>
<p>Many operations can be significantly optimized by working on stacks of frames.
You can often perform <a class="reference external" href="https://en.wikipedia.org/wiki/Loop_nest_optimization">loop nest optimization</a>
to improve the <a class="reference external" href="https://en.wikipedia.org/wiki/Locality_of_reference">locality of reference</a>,
for example using <a class="reference external" href="https://numba.pydata.org/">numba</a>, or using an optimized NumPy function.</p>
<p>As an example, applying a gain map and subtracting dark frames can be up to an order of magnitude
faster when properly optimized compared to a naive NumPy implementation.
These optimizations are only possible if you have access to data
from more than one frame.</p>
<p>For very large frames, another problem arises: a stack of frames would be too large to efficiently handle,
as it would no longer fit into even the L3 cache, which is the largest cache in most CPUs. For these
cases, we support a tiled reading and processing strategy. Tiled means we slice the frame into
disjoint rectangular regions. A tile then is the data from a single rectangular region
for multiple frames.</p>
<p>For example, in case of K2IS data, frames have a shape of <code class="code docutils literal notranslate"><span class="pre">(1860,</span> <span class="pre">2048)</span></code>. When reading them
with the tiled strategy, a single tile will contain data from 16 subsequent frames, and each
rectangle has a shape of <code class="code docutils literal notranslate"><span class="pre">(930,</span> <span class="pre">16)</span></code>, which is the natural block size for K2IS data.
That means the tiles will have a shape of <code class="code docutils literal notranslate"><span class="pre">(16,</span> <span class="pre">930,</span> <span class="pre">16)</span></code>, and processing 16 frames from the data set
means reading 256 individual tiles.</p>
<p>Loading a tile of this size as float32 data
still fits comfortably into usual L3 CPU caches (~1MB), and thus enables efficient processing.
As a comparison, a whole <code class="code docutils literal notranslate"><span class="pre">(1860,</span> <span class="pre">2048)</span></code> frame is about 15MB large, and accessing it repeatedly
means having to load data from the slower main memory.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You may have noticed that we talk about block sizes of 1MB as efficient in the L3 cache,
but many CPUs have larger L3 caches. As the L3 cache is shared between cores, and LiberTEM tries
to use multiple cores, the effectively available L3 cache has to be divided by number of cores.</p>
</div>
<div class="section" id="real-world-example">
<span id="slice-example"></span><h3>Real-world example<a class="headerlink" href="#real-world-example" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="https://libertem.github.io/LiberTEM-blobfinder/reference.html#libertem_blobfinder.udf.correlation.SparseCorrelationUDF" title="(in LiberTEM-blobfinder v0.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">libertem_blobfinder.udf.correlation.SparseCorrelationUDF</span></code></a> uses
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFTileMixin.process_tile" title="libertem.udf.base.UDFTileMixin.process_tile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">process_tile()</span></code></a> to implement a custom version of
a <a class="reference internal" href="../reference/udf.html#libertem.udf.masks.ApplyMasksUDF" title="libertem.udf.masks.ApplyMasksUDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">ApplyMasksUDF</span></code></a> that works on log-scaled data. The
mask stack is stored in a <a class="reference internal" href="../reference/internals.html#libertem.common.container.MaskContainer" title="libertem.common.container.MaskContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">libertem.common.container.MaskContainer</span></code></a> as part of
the task data. Note how the <code class="code docutils literal notranslate"><span class="pre">self.meta.slice</span></code> property of type
<a class="reference internal" href="../reference/internals.html#libertem.common.slice.Slice" title="libertem.common.slice.Slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">Slice</span></code></a> is used to extract the region from the mask
stack that matches the tile using the facilities of a
<a class="reference internal" href="../reference/internals.html#libertem.common.container.MaskContainer" title="libertem.common.container.MaskContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">MaskContainer</span></code></a>. After reshaping, transposing and log
scaling the tile data into the right memory layout, the mask stack is applied to
the data with a dot product. The result is <em>added</em> to the buffer in order to
merge it with the results of the other tiles because addition is the correct
merge function for a dot product. Other operations would require a different
merge function here, for example <code class="xref py py-meth docutils literal notranslate"><span class="pre">numpy.max()</span></code> if a global maximum is to
be calculated.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process_tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile</span><span class="p">):</span>
    <span class="n">tile_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">slice</span>
    <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_data</span><span class="p">[</span><span class="s1">&#39;mask_container&#39;</span><span class="p">]</span>
    <span class="n">tile_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">tile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">tile</span><span class="o">.</span><span class="n">dtype</span>
    <span class="p">)</span>
    <span class="n">log_scale</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">tile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tile_t</span><span class="p">)</span>

    <span class="n">sl</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">tile_slice</span><span class="p">,</span> <span class="n">transpose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">corr</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">sl</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tile_t</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="post-processing">
<span id="udf-post-processing"></span><h2>Post-processing<a class="headerlink" href="#post-processing" title="Permalink to this headline">¶</a></h2>
<p>Post-processing allows to perform additional processing steps once the data of a
partition is completely processed with
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFFrameMixin.process_frame" title="libertem.udf.base.UDFFrameMixin.process_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">process_frame()</span></code></a>,
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFTileMixin.process_tile" title="libertem.udf.base.UDFTileMixin.process_tile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">process_tile()</span></code></a> or
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFPartitionMixin.process_partition" title="libertem.udf.base.UDFPartitionMixin.process_partition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">process_partition()</span></code></a>. Post-processing is
particularly relevant for tiled processing since that allows to combine the
performance benefits of tiled processing for a first reduction step with
subsequent steps that require reduced data from complete frames or even a
complete partition.</p>
<p>Real-world example from
<a class="reference external" href="https://libertem.github.io/LiberTEM-blobfinder/reference.html#libertem_blobfinder.udf.correlation.SparseCorrelationUDF" title="(in LiberTEM-blobfinder v0.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">libertem_blobfinder.udf.correlation.SparseCorrelationUDF</span></code></a> which
evaluates the correlation maps that have been generated with the dot product in
the previous processing step and places the results in additional result
buffers:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">postprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">steps</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">corrmaps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">corr</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span>
        <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># frames</span>
        <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">peaks</span><span class="p">),</span>  <span class="c1"># peaks</span>
        <span class="n">steps</span><span class="p">,</span>  <span class="c1"># Y steps</span>
        <span class="n">steps</span><span class="p">,</span>  <span class="c1"># X steps</span>
    <span class="p">))</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">peaks</span>
    <span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">refineds</span><span class="p">,</span> <span class="n">peak_values</span><span class="p">,</span> <span class="n">peak_elevations</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_buffers</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">corrmaps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">evaluate_correlations</span><span class="p">(</span>
            <span class="n">corrs</span><span class="o">=</span><span class="n">corrmaps</span><span class="p">[</span><span class="n">f</span><span class="p">],</span> <span class="n">peaks</span><span class="o">=</span><span class="n">peaks</span><span class="p">,</span> <span class="n">crop_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">steps</span><span class="p">,</span>
            <span class="n">out_centers</span><span class="o">=</span><span class="n">centers</span><span class="p">[</span><span class="n">f</span><span class="p">],</span> <span class="n">out_refineds</span><span class="o">=</span><span class="n">refineds</span><span class="p">[</span><span class="n">f</span><span class="p">],</span>
            <span class="n">out_heights</span><span class="o">=</span><span class="n">peak_values</span><span class="p">[</span><span class="n">f</span><span class="p">],</span> <span class="n">out_elevations</span><span class="o">=</span><span class="n">peak_elevations</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">libertem.udf.base.UDFPreprocessMixin.postprocess()</span></code> method is called
for each partition on the worker process, before the results from different
partitions have been merged. If you want to implement a final post-processing
step that is run on the main node, you can override
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDF.get_results" title="libertem.udf.base.UDF.get_results"><code class="xref py py-meth docutils literal notranslate"><span class="pre">libertem.udf.base.UDF.get_results()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AverageUDF</span><span class="p">(</span><span class="n">UDF</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Like SumUDF, but also computes the average</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">get_result_buffers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;sum&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;sig&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="s1">&#39;num_frames&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">),</span>
            <span class="s1">&#39;average&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;sig&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">use</span><span class="o">=</span><span class="s1">&#39;result_only&#39;</span><span class="p">),</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">process_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">sum</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">frame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">num_frames</span><span class="p">[:]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>
        <span class="n">dest</span><span class="o">.</span><span class="n">sum</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">src</span><span class="o">.</span><span class="n">sum</span>
        <span class="n">dest</span><span class="o">.</span><span class="n">num_frames</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">src</span><span class="o">.</span><span class="n">num_frames</span>

    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="c1"># NOTE: &#39;sum&#39; omitted here, will be returned unchanged</span>
            <span class="s1">&#39;average&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">sum</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">num_frames</span><span class="p">,</span>
        <span class="p">}</span>

<span class="n">ctx</span><span class="o">.</span><span class="n">run_udf</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">udf</span><span class="o">=</span><span class="n">AverageUDF</span><span class="p">())</span>
</pre></div>
</div>
<p>Note that <code class="xref py py-meth docutils literal notranslate"><span class="pre">UDF.get_result_buffers()</span></code> returns a placeholder entry for the
<code class="code docutils literal notranslate"><span class="pre">average</span></code> result using <code class="code docutils literal notranslate"><span class="pre">use='result_only'</span></code>, which is then filled in
<code class="code docutils literal notranslate"><span class="pre">get_results</span></code>.  We don’t need to repeat those buffers that should be
returned unchanged; if you want to omit a buffer from the results completely,
you can declare it as private with <code class="code docutils literal notranslate"><span class="pre">self.buffer(...,</span> <span class="pre">use='private')</span></code> in
<code class="code docutils literal notranslate"><span class="pre">get_result_buffers</span></code>.</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">UDF.get_results()</span></code> should return the results as a dictionary of numpy
arrays, with the keys matching those returned by
<code class="xref py py-meth docutils literal notranslate"><span class="pre">UDF.get_result_buffers()</span></code>.</p>
<p>When returned from <code class="xref py py-meth docutils literal notranslate"><span class="pre">Context.run_udf()</span></code>, all results are wrapped into
<code class="code docutils literal notranslate"><span class="pre">BufferWrapper</span></code> instances. This is done primarily to get convenient
access to a version of the result that is suitable for visualization, even if
a <code class="code docutils literal notranslate"><span class="pre">roi</span></code> was used, but still allow access to the raw result using
<code class="xref py py-attr docutils literal notranslate"><span class="pre">BufferWrapper.raw_data</span></code> attribute.</p>
<p>The detailed rules for buffer declarations, <code class="code docutils literal notranslate"><span class="pre">get_result_buffers</span></code> and <code class="code docutils literal notranslate"><span class="pre">get_results</span></code> are:</p>
<ol class="arabic simple">
<li><p>All buffers are declared in <code class="code docutils literal notranslate"><span class="pre">get_result_buffers</span></code></p></li>
<li><p>If a buffer is only computed in <code class="code docutils literal notranslate"><span class="pre">get_results</span></code>, it should be marked via
<code class="code docutils literal notranslate"><span class="pre">use='result_only'</span></code> so it isn’t allocated on workers</p></li>
<li><p>If a buffer is only used as intermediary result, it should be marked via <code class="code docutils literal notranslate"><span class="pre">use='private'</span></code></p></li>
<li><p>Not including a buffer in <code class="code docutils literal notranslate"><span class="pre">get_results</span></code> means it will either be passed on
unchanged, or dropped if <code class="code docutils literal notranslate"><span class="pre">use='private'</span></code></p></li>
<li><p>It’s an error to omit an <code class="code docutils literal notranslate"><span class="pre">use='result_only'</span></code> buffer in <code class="code docutils literal notranslate"><span class="pre">get_results</span></code></p></li>
<li><p>It’s an error to include a <code class="code docutils literal notranslate"><span class="pre">use='private'</span></code> buffer in <code class="code docutils literal notranslate"><span class="pre">get_results</span></code></p></li>
<li><p>All results are returned from <code class="code docutils literal notranslate"><span class="pre">Context.run_udf</span></code> as <code class="code docutils literal notranslate"><span class="pre">BufferWrapper</span></code> instances</p></li>
<li><p>By default, if <code class="code docutils literal notranslate"><span class="pre">get_results</span></code> is not implemented, <code class="code docutils literal notranslate"><span class="pre">use='private'</span></code> buffers are dropped,
and others are passed through unchanged</p></li>
</ol>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.7.0: </span><code class="xref py py-meth docutils literal notranslate"><span class="pre">UDF.get_results()</span></code> and the <code class="code docutils literal notranslate"><span class="pre">use</span></code> argument for <code class="xref py py-meth docutils literal notranslate"><span class="pre">UDF.buffer()</span></code> were added.</p>
</div>
</div>
<div class="section" id="pre-processing">
<h2>Pre-processing<a class="headerlink" href="#pre-processing" title="Permalink to this headline">¶</a></h2>
<p>Pre-processing allows to initialize result buffers before processing or merging.
This is particularly useful to set up <code class="code docutils literal notranslate"><span class="pre">dtype=object</span></code> buffers, for example
ragged arrays, or to initialize buffers for operations where the neutral element
is not 0. <a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFPreprocessMixin.preprocess" title="libertem.udf.base.UDFPreprocessMixin.preprocess"><code class="xref py py-meth docutils literal notranslate"><span class="pre">libertem.udf.base.UDFPreprocessMixin.preprocess()</span></code></a> is executed after
all buffers are allocated, but before the data is processed. On the worker nodes
it is executed with views set for the whole partition masked by the current ROI.
On the central node it is executed with views set for the whole dataset masked
by the ROI.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.3.0.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.5.0: </span><a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFPreprocessMixin.preprocess" title="libertem.udf.base.UDFPreprocessMixin.preprocess"><code class="xref py py-meth docutils literal notranslate"><span class="pre">libertem.udf.base.UDFPreprocessMixin.preprocess()</span></code></a> is executed on the main
node, too. Views for aux data are set correctly on the main node. Previously,
it was only executed on the worker nodes.</p>
</div>
</div>
<div class="section" id="partition-processing">
<h2>Partition processing<a class="headerlink" href="#partition-processing" title="Permalink to this headline">¶</a></h2>
<p>Some algorithms can benefit from processing entire partitions, for example if
they require several passes over the data. In most cases, <a class="reference internal" href="#tiled"><span class="std std-ref">tiled
processing</span></a> will be faster because it uses the L3 cache more efficiently.
For that reason, per-partition processing should only be used if there are clear
indications for it. Implementing
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFPartitionMixin.process_partition" title="libertem.udf.base.UDFPartitionMixin.process_partition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">process_partition()</span></code></a> activates
per-partition processing for an UDF.</p>
</div>
<div class="section" id="precedence">
<h2>Precedence<a class="headerlink" href="#precedence" title="Permalink to this headline">¶</a></h2>
<p>The UDF interface looks for methods in the order
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFTileMixin.process_tile" title="libertem.udf.base.UDFTileMixin.process_tile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">process_tile()</span></code></a>,
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFFrameMixin.process_frame" title="libertem.udf.base.UDFFrameMixin.process_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">process_frame()</span></code></a>,
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFPartitionMixin.process_partition" title="libertem.udf.base.UDFPartitionMixin.process_partition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">process_partition()</span></code></a>. For now, the first in
that order is executed. In the future, composition of UDFs may allow to use
different methods depending on the circumstances.
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFTileMixin.process_tile" title="libertem.udf.base.UDFTileMixin.process_tile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">process_tile()</span></code></a> is the most general method and
allows by-frame and by-partition processing as well.</p>
</div>
<div class="section" id="aux-data">
<h2>AUX data<a class="headerlink" href="#aux-data" title="Permalink to this headline">¶</a></h2>
<p>If a parameter is an instance of <a class="reference internal" href="../reference/udf.html#libertem.common.buffers.BufferWrapper" title="libertem.common.buffers.BufferWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferWrapper</span></code></a>
that was created using the <a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDF.aux_data" title="libertem.udf.base.UDF.aux_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aux_data()</span></code></a> class method, the
UDF interface will interpret it as auxiliary data. It will set the views for
each tile/frame/partition accordingly so that accessing the parameter returns a
view of the auxiliary data matching the data portion that is currently being
processed. That way, it is possible to pass parameters individually for each
frame or to mask the signal dimension.</p>
<p>Note that the <a class="reference internal" href="../reference/udf.html#libertem.common.buffers.BufferWrapper" title="libertem.common.buffers.BufferWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferWrapper</span></code></a> instance for AUX
data should always be created using the <a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDF.aux_data" title="libertem.udf.base.UDF.aux_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aux_data()</span></code></a> class
method and not directly by instantiating a
<a class="reference internal" href="../reference/udf.html#libertem.common.buffers.BufferWrapper" title="libertem.common.buffers.BufferWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferWrapper</span></code></a> since
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDF.aux_data" title="libertem.udf.base.UDF.aux_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aux_data()</span></code></a> ensures that it is set up correctly.</p>
<p>For masks in the signal dimension that are used for dot products in combination
with per-tile processing, a <a class="reference internal" href="../reference/internals.html#libertem.common.container.MaskContainer" title="libertem.common.container.MaskContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">MaskContainer</span></code></a> allows
to use more advanced slicing and transformation methods targeted at preparing
mask stacks for optimal dot product performance.</p>
</div>
<div class="section" id="task-data">
<h2>Task data<a class="headerlink" href="#task-data" title="Permalink to this headline">¶</a></h2>
<p>A UDF can generate task-specific intermediate data on the worker nodes by
defining a <a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDF.get_task_data" title="libertem.udf.base.UDF.get_task_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_task_data()</span></code></a> method. The result is
available as an instance of <a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFData" title="libertem.udf.base.UDFData"><code class="xref py py-class docutils literal notranslate"><span class="pre">UDFData</span></code></a> in
<code class="code docutils literal notranslate"><span class="pre">self.task_data</span></code>. Depending on the circumstances, this can be more
efficient than making the data available as a parameter since it avoids
pickling, network transport and unpickling.</p>
<p>This non-trivial example from
<a class="reference external" href="https://libertem.github.io/LiberTEM-blobfinder/reference.html#libertem_blobfinder.udf.correlation.SparseCorrelationUDF" title="(in LiberTEM-blobfinder v0.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">libertem_blobfinder.udf.correlation.SparseCorrelationUDF</span></code></a> creates
a <a class="reference internal" href="../reference/internals.html#libertem.common.container.MaskContainer" title="libertem.common.container.MaskContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">MaskContainer</span></code></a> based on the parameters in
<code class="code docutils literal notranslate"><span class="pre">self.params</span></code>. This <a class="reference internal" href="../reference/internals.html#libertem.common.container.MaskContainer" title="libertem.common.container.MaskContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">MaskContainer</span></code></a> is then
available as <code class="code docutils literal notranslate"><span class="pre">self.task_data['mask_container']</span></code> within the processing
functions.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_task_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">match_pattern</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">match_pattern</span>
    <span class="n">crop_size</span> <span class="o">=</span> <span class="n">match_pattern</span><span class="o">.</span><span class="n">get_crop_size</span><span class="p">()</span>
    <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">crop_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">crop_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">template</span> <span class="o">=</span> <span class="n">match_pattern</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="n">sig_shape</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">steps</span>
    <span class="n">peak_offsetY</span><span class="p">,</span> <span class="n">peak_offsetX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="n">steps</span><span class="p">:</span><span class="n">steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">steps</span><span class="p">:</span><span class="n">steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="n">offsetY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">peak_offsetY</span> <span class="o">-</span> <span class="n">crop_size</span>
    <span class="n">offsetX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">peak_offsetX</span> <span class="o">-</span> <span class="n">crop_size</span>

    <span class="n">offsetY</span> <span class="o">=</span> <span class="n">offsetY</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">offsetX</span> <span class="o">=</span> <span class="n">offsetX</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
        <span class="n">masks</span><span class="o">.</span><span class="n">sparse_template_multi_stack</span><span class="p">,</span>
        <span class="n">mask_index</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">offsetY</span><span class="p">)),</span>
        <span class="n">offsetX</span><span class="o">=</span><span class="n">offsetX</span><span class="p">,</span>
        <span class="n">offsetY</span><span class="o">=</span><span class="n">offsetY</span><span class="p">,</span>
        <span class="n">template</span><span class="o">=</span><span class="n">template</span><span class="p">,</span>
        <span class="n">imageSizeX</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">dataset_shape</span><span class="o">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">imageSizeY</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">dataset_shape</span><span class="o">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="c1"># CSC matrices in combination with transposed data are fastest</span>
    <span class="n">container</span> <span class="o">=</span> <span class="n">MaskContainer</span><span class="p">(</span><span class="n">mask_factories</span><span class="o">=</span><span class="n">stack</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
        <span class="n">use_sparse</span><span class="o">=</span><span class="s1">&#39;scipy.sparse.csc&#39;</span><span class="p">)</span>

    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;mask_container&#39;</span><span class="p">:</span> <span class="n">container</span><span class="p">,</span>
        <span class="s1">&#39;crop_size&#39;</span><span class="p">:</span> <span class="n">crop_size</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">kwargs</span>
</pre></div>
</div>
</div>
<div class="section" id="meta-information">
<h2>Meta information<a class="headerlink" href="#meta-information" title="Permalink to this headline">¶</a></h2>
<p>Advanced processing routines may require context information about the processed
data set, ROI and current data portion being processed. This information is
available as properties of the <code class="xref py py-attr docutils literal notranslate"><span class="pre">libertem.udf.base.UDF.meta</span></code> attribute of type
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFMeta" title="libertem.udf.base.UDFMeta"><code class="xref py py-class docutils literal notranslate"><span class="pre">UDFMeta</span></code></a>.</p>
<p>Common applications include allocating buffers with a <code class="code docutils literal notranslate"><span class="pre">dtype</span></code> or shape
that matches the dataset or partition via
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFMeta.dataset_dtype" title="libertem.udf.base.UDFMeta.dataset_dtype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dataset_dtype</span></code></a>,
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFMeta.input_dtype" title="libertem.udf.base.UDFMeta.input_dtype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dtype</span></code></a>,
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFMeta.dataset_shape" title="libertem.udf.base.UDFMeta.dataset_shape"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dataset_shape</span></code></a> and
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFMeta.partition_shape" title="libertem.udf.base.UDFMeta.partition_shape"><code class="xref py py-attr docutils literal notranslate"><span class="pre">partition_shape</span></code></a>.</p>
<p>The currently used compute device class can be accessed through
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFMeta.device_class" title="libertem.udf.base.UDFMeta.device_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">libertem.udf.base.UDFMeta.device_class</span></code></a>. It defaults to ‘cpu’ and can be ‘cuda’
for UDFs that make use of <a class="reference internal" href="#udf-cuda"><span class="std std-ref">CuPy support</span></a> support.</p>
<p>For more advanced applications, the ROI and currently processed data portion are
available as <a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFMeta.roi" title="libertem.udf.base.UDFMeta.roi"><code class="xref py py-attr docutils literal notranslate"><span class="pre">libertem.udf.base.UDFMeta.roi</span></code></a> and
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDFMeta.slice" title="libertem.udf.base.UDFMeta.slice"><code class="xref py py-attr docutils literal notranslate"><span class="pre">libertem.udf.base.UDFMeta.slice</span></code></a>. This allows to replace the built-in masking
behavior of <a class="reference internal" href="../reference/udf.html#libertem.common.buffers.BufferWrapper" title="libertem.common.buffers.BufferWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferWrapper</span></code></a> for result buffers
and aux data with a custom implementation. The <a class="reference internal" href="#slice-example"><span class="std std-ref">mask container for tiled
processing example</span></a> makes use of these attributes to employ a
<a class="reference internal" href="../reference/internals.html#libertem.common.container.MaskContainer" title="libertem.common.container.MaskContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">libertem.common.container.MaskContainer</span></code></a> instead of a <code class="code docutils literal notranslate"><span class="pre">shape=&quot;sig&quot;</span></code>
buffer in order to optimize dot product performance and support sparse masks.</p>
<p>The slice is in the reference frame of the dataset, masked by the current ROI,
with flattened navigation dimension. This example illustrates the behavior by
implementing a custom version of the <a class="reference internal" href="../udf.html#sumsig"><span class="std std-ref">simple “sum over sig” example</span></a>. It allocates a custom result buffer that matches the navigation
dimension as it appears in processing:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">libertem.udf</span> <span class="kn">import</span> <span class="n">UDF</span>

<span class="k">class</span> <span class="nc">PixelsumUDF</span><span class="p">(</span><span class="n">UDF</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_result_buffers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">roi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">navsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">roi</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">navsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">dataset_shape</span><span class="o">.</span><span class="n">nav</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;pixelsum_nav_raw&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span>
                <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;single&quot;</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">dataset_dtype</span><span class="p">,</span>
                <span class="n">extra_shape</span><span class="o">=</span><span class="p">(</span><span class="n">navsize</span><span class="p">,</span> <span class="p">),</span>
            <span class="p">)</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>
        <span class="n">dest</span><span class="o">.</span><span class="n">pixelsum_nav_raw</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">src</span><span class="o">.</span><span class="n">pixelsum_nav_raw</span>

    <span class="k">def</span> <span class="nf">process_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
        <span class="n">np_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">slice</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">nav_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">pixelsum_nav_raw</span><span class="p">[</span><span class="n">np_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="dtype-support">
<span id="udf-dtype"></span><h2>dtype support<a class="headerlink" href="#dtype-support" title="Permalink to this headline">¶</a></h2>
<p>UDFs can override <a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDF.get_preferred_input_dtype" title="libertem.udf.base.UDF.get_preferred_input_dtype"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_preferred_input_dtype()</span></code></a> to
indicate a “lowest common denominator” compatible dtype. The actual input dtype
is determined by combining the indicated preferred dtype with the input
dataset’s native dtype using <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.result_type.html#numpy.result_type" title="(in NumPy v1.20)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.result_type()</span></code></a>. The default preferred
dtype is <a class="reference external" href="https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.float32" title="(in NumPy v1.20)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">numpy.float32</span></code></a>. Returning <code class="xref py py-attr docutils literal notranslate"><span class="pre">UDF.USE_NATIVE_DTYPE</span></code>, which is
currently identical to <code class="code docutils literal notranslate"><span class="pre">numpy.bool</span></code>, will switch to the dataset’s native
dtype since <code class="code docutils literal notranslate"><span class="pre">numpy.bool</span></code> behaves as a neutral element in
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.result_type.html#numpy.result_type" title="(in NumPy v1.20)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.result_type()</span></code></a>.</p>
<p>If an UDF requires a specific dtype rather than only preferring it, it should
override this method and additionally check the actual input type, throw an
error when used incorrectly and/or implement a meaningful conversion in its
processing routine since indicating a preferred dtype doesn’t enforce it. That
way, unsafe conversions are performed explicitly in the UDF rather than
indirectly in the back-end.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.4.0.</span></p>
</div>
</div>
<div class="section" id="cupy-support">
<span id="udf-cuda"></span><h2>CuPy support<a class="headerlink" href="#cupy-support" title="Permalink to this headline">¶</a></h2>
<p>LiberTEM can use CUDA devices through <a class="reference external" href="https://cupy.chainer.org/">CuPy</a>. Since
CuPy largely replicates the NumPy array interface, any UDF that uses NumPy for
its main processing can likely be ported to use both CPUs and CUDA devices in
parallel. Some adjustments are often necessary to account for minor differences
between NumPy and CuPy. CuPy is most beneficial for compute-heavy tasks with
good CUDA math library support such as large Fourier transforms or matrix
products.</p>
<p>In order to activate CuPy processing, a UDF can overwrite the
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDF.get_backends" title="libertem.udf.base.UDF.get_backends"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_backends()</span></code></a> method. By default this returns
<code class="code docutils literal notranslate"><span class="pre">('numpy',)</span></code>, indicating only NumPy support. By returning <code class="code docutils literal notranslate"><span class="pre">('numpy',</span>
<span class="pre">'cupy')</span></code> or <code class="code docutils literal notranslate"><span class="pre">('cupy',)</span></code>, a UDF activates being run on both CUDA and CPU
workers, or exclusively on CUDA workers. Using <code class="code docutils literal notranslate"><span class="pre">cuda</span></code> instead of
<code class="code docutils literal notranslate"><span class="pre">cupy</span></code> schedules on CUDA workers, but without using the CuPy library. This
is useful for running code that uses CUDA in a different way, for example
integration of C++ CUDA code, and allows to skip installation of CuPy in this
situation.</p>
<p>The <code class="xref py py-attr docutils literal notranslate"><span class="pre">libertem.udf.base.UDF.xp</span></code> property points to the <code class="code docutils literal notranslate"><span class="pre">numpy</span></code> or
<code class="code docutils literal notranslate"><span class="pre">cupy</span></code> module, depending which back-end is currently used. By using
<code class="code docutils literal notranslate"><span class="pre">self.xp</span></code> instead of the usual <code class="code docutils literal notranslate"><span class="pre">np</span></code> for NumPy, one can write UDFs
that use the same code for CUDA and CPU processing.</p>
<p>Result buffers can be declared as device arrays by setting
<code class="code docutils literal notranslate"><span class="pre">self.buffer(...,</span> <span class="pre">where='device')</span></code> in
<a class="reference internal" href="../reference/udf.html#libertem.udf.base.UDF.get_result_buffers" title="libertem.udf.base.UDF.get_result_buffers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_result_buffers()</span></code></a>. That allows to keep data in
the device until a partition is completely processed and the result is exported
to the leader node.</p>
<p>The input argument for <code class="code docutils literal notranslate"><span class="pre">process_*()</span></code> functions is already provided as a
CuPy array instead of NumPy array if CuPy is used.</p>
<p>A UDF should only use one GPU at a time. If <code class="code docutils literal notranslate"><span class="pre">cupy</span></code> is used, the correct
device to use is set within CuPy in the back-end and should not be modified in
the UDF itself. If <code class="code docutils literal notranslate"><span class="pre">cuda</span></code> is used, it is the responsibility of the user to
set the device ID to the value returned by
<a class="reference internal" href="../reference/internals.html#libertem.common.backend.get_use_cuda" title="libertem.common.backend.get_use_cuda"><code class="xref py py-meth docutils literal notranslate"><span class="pre">libertem.common.backend.get_use_cuda()</span></code></a>. The environment variable
<code class="code docutils literal notranslate"><span class="pre">CUDA_VISIBLE_DEVICES</span></code> can be set <cite>before</cite> any CUDA library is loaded to
control which devices are visible.</p>
<p>The <a class="reference internal" href="../reference/api.html#libertem.api.Context.run_udf" title="libertem.api.Context.run_udf"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_udf()</span></code></a> method allows setting the
<code class="code docutils literal notranslate"><span class="pre">backends</span></code> attribute to <code class="code docutils literal notranslate"><span class="pre">('numpy',)</span></code> <code class="code docutils literal notranslate"><span class="pre">('cupy',)</span></code> or <code class="code docutils literal notranslate"><span class="pre">('cuda',)</span></code> to
restrict execution to CPU-only or CUDA-only on a hybrid cluster. This is mostly
useful for testing.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.6.0.</span></p>
</div>
</div>
<div class="section" id="auto-udf">
<span id="id1"></span><h2>Auto UDF<a class="headerlink" href="#auto-udf" title="Permalink to this headline">¶</a></h2>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">AutoUDF</span></code> class and <a class="reference internal" href="../reference/api.html#libertem.api.Context.map" title="libertem.api.Context.map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">map()</span></code></a>
method allow to run simple functions that accept a frame as the only parameter
with an auto-generated <code class="code docutils literal notranslate"><span class="pre">kind=&quot;nav&quot;</span></code> result buffer over a dataset ad-hoc
without defining an UDF class. For more advanced processing, such as custom
merge functions, post-processing or performance optimization through tiled
processing, defining an UDF class is required.</p>
<p>As an alternative to Auto UDF, you can use the
<a class="reference internal" href="../reference/dask.html#libertem.contrib.daskadapter.make_dask_array" title="libertem.contrib.daskadapter.make_dask_array"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_dask_array()</span></code></a> method to create
a <a class="reference external" href="https://docs.dask.org/en/latest/array.html">dask.array</a> from
a <a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.DataSet" title="libertem.io.dataset.base.DataSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataSet</span></code></a> to perform calculations. See
<a class="reference internal" href="../api.html#daskarray"><span class="std std-ref">Integration with Dask arrays</span></a> for more details.</p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">AutoUDF</span></code> class determines the output shape and type
by calling the function with a mock-up frame of the same type and shape as
a real detector frame and converting the return value to a NumPy array. The
<code class="code docutils literal notranslate"><span class="pre">extra_shape</span></code> and <code class="code docutils literal notranslate"><span class="pre">dtype</span></code> parameters for the result buffer are
derived automatically from this NumPy array.</p>
<p>Additional constant parameters can be passed to the function via
<code class="xref py py-meth docutils literal notranslate"><span class="pre">functools.partial()</span></code>, for example. The return value should be much smaller
than the input size for this to work efficiently.</p>
<p>Example: Calculate sum over the last signal axis.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">functools</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
    <span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span>
    <span class="n">f</span><span class="o">=</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1"># or alternatively:</span>
<span class="kn">from</span> <span class="nn">libertem.udf</span> <span class="kn">import</span> <span class="n">AutoUDF</span>

<span class="n">udf</span> <span class="o">=</span> <span class="n">AutoUDF</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">run_udf</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">udf</span><span class="o">=</span><span class="n">udf</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="live-plotting">
<span id="plotting"></span><h2>Live Plotting<a class="headerlink" href="#live-plotting" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.7.0.</span></p>
</div>
<p>LiberTEM can display a live plot of the UDF results. In the most simple case,
this can be done by setting <code class="code docutils literal notranslate"><span class="pre">plots=True</span></code> in
<a class="reference internal" href="../reference/api.html#libertem.api.Context.run_udf" title="libertem.api.Context.run_udf"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_udf()</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ctx</span><span class="o">.</span><span class="n">run_udf</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">udf</span><span class="o">=</span><span class="n">udf</span><span class="p">,</span> <span class="n">plots</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>See the following items for a full demonstration, including setting up fully
customized plots. The API reference can be found in <a class="reference internal" href="../reference/viz.html#viz-reference"><span class="std std-ref">Visualization</span></a>.</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="liveplotting.html">Live plotting for LiberTEM UDFs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="liveplotting.html#Plot-classes">Plot classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="liveplotting.html#Demo-UDFs">Demo UDFs</a></li>
<li class="toctree-l2"><a class="reference internal" href="liveplotting.html#Plot-all-plottable-channels">Plot all plottable channels</a></li>
<li class="toctree-l2"><a class="reference internal" href="liveplotting.html#Select-specific-channels">Select specific channels</a></li>
<li class="toctree-l2"><a class="reference internal" href="liveplotting.html#Apply-a-function-to-a-channel">Apply a function to a channel</a></li>
<li class="toctree-l2"><a class="reference internal" href="liveplotting.html#Custom-plot-setup">Custom plot setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="liveplotting.html#Gridded-display">Gridded display</a><ul>
<li class="toctree-l3"><a class="reference internal" href="liveplotting.html#What-it-looks-like">What it looks like</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="liveplotting.html#User-defined-plotting">User-defined plotting</a></li>
<li class="toctree-l2"><a class="reference internal" href="liveplotting.html#Region-of-interest-(ROI)">Region of interest (ROI)</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="partial-results">
<h2>Partial results<a class="headerlink" href="#partial-results" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.7.0.</span></p>
</div>
<p>Instead of only getting the whole result after the UDF has finished running, you
can also use <a class="reference internal" href="../reference/api.html#libertem.api.Context.run_udf_iter" title="libertem.api.Context.run_udf_iter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_udf_iter()</span></code></a> to get a generator for
partial results:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">udf_results</span> <span class="ow">in</span> <span class="n">ctx</span><span class="o">.</span><span class="n">run_udf_iter</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">udf</span><span class="o">=</span><span class="n">udf</span><span class="p">):</span>
    <span class="c1"># ... do something interesting with `udf_results`:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">udf_results</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;intensity&#39;</span><span class="p">])</span>

<span class="c1"># after the loop, `udf_results` contains the final results as usual</span>
</pre></div>
</div>
<p>While the UDF execution is running, the UDF object should not be modified since
that leads to undefined behavior. In particular, nested or concurrent execution
of the same UDF objects must be avoided since it modifies the buffers that are
allocated internally while a UDF is running.</p>
<p>It is also possible to integrate LiberTEM into an async script or application by
passing <code class="code docutils literal notranslate"><span class="pre">sync=False</span></code> to <a class="reference internal" href="../reference/api.html#libertem.api.Context.run_udf_iter" title="libertem.api.Context.run_udf_iter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_udf_iter()</span></code></a> or
<a class="reference internal" href="../reference/api.html#libertem.api.Context.run_udf" title="libertem.api.Context.run_udf"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_udf()</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">for</span> <span class="n">udf_results</span> <span class="ow">in</span> <span class="n">ctx</span><span class="o">.</span><span class="n">run_udf_iter</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">udf</span><span class="o">=</span><span class="n">udf</span><span class="p">,</span> <span class="n">sync</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># ... do something interesting with `udf_results`:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">udf_results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;intensity&#39;</span><span class="p">])</span>

<span class="c1"># or the version without intermediate results:</span>
<span class="n">udf_results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">ctx</span><span class="o">.</span><span class="n">run_udf</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">udf</span><span class="o">=</span><span class="n">udf</span><span class="p">,</span> <span class="n">sync</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>See the items below for a more comprehensive demonstration and documentation:</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="async.html">Synchronous and asynchronous UDF execution</a><ul>
<li class="toctree-l2"><a class="reference internal" href="async.html#Synchronous-execution,-only-result">Synchronous execution, only result</a></li>
<li class="toctree-l2"><a class="reference internal" href="async.html#Asynchronous-execution,-only-result">Asynchronous execution, only result</a></li>
<li class="toctree-l2"><a class="reference internal" href="async.html#Synchronous-execution-as-an-iterator">Synchronous execution as an iterator</a></li>
<li class="toctree-l2"><a class="reference internal" href="async.html#Asynchronous-execution-as-an-iterator">Asynchronous execution as an iterator</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="liveplotting.html" class="btn btn-neutral float-right" title="Live plotting for LiberTEM UDFs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="../udf.html" class="btn btn-neutral float-left" title="User-defined functions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, LiberTEM Authors.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>